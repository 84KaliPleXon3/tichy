			    Tichy internal

Tichy's internal may be a little bit hard to understand because of
it's object oriented structure and the fact that is uses some patterns
that couldn't be done with C++ (at least not without huge pain).

The documentation can be auto-generated from the code using epydoc,
[but we need to clean the code a little]

In the doc directory, there is also a .dia file with the basic UML of
a few important classes, and a .svg drawing of the same file.

Here are the important classes of tichy's internal structure. Refer to
the auto-generated doc or the code itself for more info.

Object:

  tichy.Object is a class that defines the slot/signal pattern.  It is
  similar to a gobject. Most of the classes in tichy inherit from
  Object, wich means that most things can emit signals.


Item:

  In tichy many classes inherit from the Item class. Item are used to
  represent all actual information. Example of Item are : Text,
  TelNumber, List, Contact, Application, etc.

  All the Item have a `get_text` method, that return a Text object.

  They also all have a `view` method, that can be used to create a
  representation of the item.


Actor:

  Every Item also have a `create_actor` method, that returns an Actor
  object. An Actor is a special Item that can be used to trigger
  actions on an other item. 

  For example a contacts application doesn't want to show all the
  contacts information in a single window, but rather shows a way for
  the user to *select* one contact and then trigger some action on
  it. On of the action could be to view the full contact.

  The usual approach would have been to create a list of buttons, one
  per contact. But this doesn't allow the Deign service to choose an
  other way to let the user select a contact. The solution is to use a
  list of actor on item, and let the Design service shows it the way
  it wants.

  Most applications in Tichy simply retrieve a list of Item and then
  show actors on those items.


Service:

  Service is a special Item that is a singleton (You can have only one
  instance of each Service class).

  Every service has a 'service' attribute that is the name of the
  service it implements. Several services can have the same service
  name.

  The Service function -yes, Service is both a class and a function
  thanks to some python magic- return an instance of a Service
  implementing a given service name. for example :
  
    tichy.Service('Caller')

  will return a service instance that implements the 'Caller' service.


Design:

  Design is a tichy Service that is in charge of creating all the
  items's views on the screen. Basically every item.view method will
  retreive the Design service and call one of the view_xxx methods of
  it.

  Since it is a service, you can have several Design implementations.


Plugin:

  At startup tichy will import a set of python scripts in the plugin
  directory. All Item classes found are registered (using python
  meta-class magic) and can later be used.


Tasklet:

  tichy.tasklet module is a solution to the complicated problem of
  callback based software.

  Since tichy runs app in a single process, it uses callback all the
  time. No part of the code can block. Now the problem with callbacks
  is that they tend to make the code unreadable, cause you need to
  split your functions in several sub functions.

  Tasklets uses python coroutines to simulate multi process code using
  callbacks. It works like this : from within a tasklet the yield
  statement may represents a branching to an other tasklet.  The task
  will exit and be resumed only after the called tasklet returns.

  e.g. :

    yield tichy.tasklet.Wait(my_obj, 'something')

  means that the current tasklet will stop at this point until my_obj
  emit the signal 'something'

